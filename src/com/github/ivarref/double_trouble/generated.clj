(ns com.github.ivarref.double-trouble.generated
  (:require [clojure.edn :as edn]
            [datomic.api]))

; Generated code below, do not edit:
(def generated {:dt/cas "{:db/ident :dt/cas :db/fn #db/fn {:lang \"clojure\", :requires [[clojure.walk :as walk] [datomic.api :as d]], :imports [(java.util HashSet List) (datomic.db DbId)], :params [db e-or-lookup-ref attr old-val new-val sha], :code (let [] (letfn [(to-clojure-types [m] (do (walk/prewalk (fn [e] (cond (instance? String e) e (instance? HashSet e) (into #{} e) (and (instance? List e) (not (vector? e))) (vec e) :else e)) m))) (is-identity? [db attr] (do (= :db.unique/identity (d/q (quote [:find ?ident . :in $ ?e :where [?e :db/unique ?typ] [?typ :db/ident ?ident]]) db attr)))) (is-unique-value? [db attr] (do (= :db.unique/value (d/q (quote [:find ?ident . :in $ ?e :where [?e :db/unique ?typ] [?typ :db/ident ?ident]]) db attr)))) (get-val [db e a] (do (d/q (quote [:find ?v . :in $ ?e ?a :where [?e ?a ?v]]) db e a))) (sha-exists? [db sha] (do (some? (d/q (quote [:find ?tx . :in $ ?sha :where [?tx :com.github.ivarref.double-trouble/sha-1 ?sha]]) db sha)))) (cas-ok [db lookup-ref a new-val sha] (do (if (sha-exists? db sha) (d/cancel {:com.github.ivarref.double-trouble/code :sha-exists, :cognitect.anomalies/message (str \"SHA already exists! SHA: \" sha), :cognitect.anomalies/category :cognitect.anomalies/incorrect, :com.github.ivarref.double-trouble/sha sha, :com.github.ivarref.double-trouble/lookup-ref lookup-ref}) [[:db/add lookup-ref a new-val] [:db/add \"datomic.tx\" :com.github.ivarref.double-trouble/sha-1 sha]]))) (most-recent-assert [db e a] (do (d/q (quote [:find (max ?tx) . :in $ ?e ?a :where [?e ?a _ ?tx true]]) (d/history db) e a))) (already-written?->tx [db e a old-val new-val sha] (do (if (some? old-val) (d/q (quote [:find ?tx . :in $ ?e ?a ?old-val ?new-val ?sha :where [?e ?a ?old-val ?tx false] [?e ?a ?new-val ?tx true] [?tx :com.github.ivarref.double-trouble/sha-1 ?sha ?tx true]]) (d/history db) e a old-val new-val sha) (let [tx-write (d/q (quote [:find [?tx ?op] :in $ ?e ?a ?new-val ?sha :where [?e ?a ?new-val ?tx ?op] [?tx :com.github.ivarref.double-trouble/sha-1 ?sha ?tx true]]) (d/history db) e a new-val sha)] (if (and (= 2 (count tx-write)) (true? (last tx-write))) (first tx-write) nil))))) (cas-mismatch [db e a old-val new-val sha] (do (if-some [tx-written (already-written?->tx db e a old-val new-val sha)] (if (= tx-written (most-recent-assert db e a)) (d/cancel {:com.github.ivarref.double-trouble/e e, :com.github.ivarref.double-trouble/code :already-transacted, :com.github.ivarref.double-trouble/tx tx-written, :com.github.ivarref.double-trouble/a a, :cognitect.anomalies/message \"Already transacted\", :com.github.ivarref.double-trouble/new-val new-val, :cognitect.anomalies/category :cognitect.anomalies/conflict, :com.github.ivarref.double-trouble/old-val old-val, :com.github.ivarref.double-trouble/sha sha}) [[:db/cas e a old-val new-val]]) [[:db/cas e a old-val new-val]]))) (cas-inner-2 [db lookup-ref a old-val new-val sha] (do (if-let [e (:db/id (d/pull db [:db/id] lookup-ref))] (let [curr-val (get-val db e a)] (if (= curr-val old-val) (cas-ok db lookup-ref a new-val sha) (cas-mismatch db e a old-val new-val sha))) (d/cancel {:com.github.ivarref.double-trouble/code :could-not-find-entity, :cognitect.anomalies/message \"Could not find entity\", :cognitect.anomalies/category :cognitect.anomalies/incorrect, :com.github.ivarref.double-trouble/lookup-ref lookup-ref})))) (cas-inner [db e-or-lookup-ref a old-val new-val sha] (do (cond (string? e-or-lookup-ref) (d/cancel {:cognitect.anomalies/message \"Entity cannot be string\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}) (instance? DbId e-or-lookup-ref) (d/cancel {:cognitect.anomalies/message \"Entity cannot be tempid/datomic.db.DbId\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}) (int? e-or-lookup-ref) (cas-inner-2 db e-or-lookup-ref a old-val new-val sha) (and (vector? e-or-lookup-ref) (= 2 (count e-or-lookup-ref)) (or (is-identity? db (first e-or-lookup-ref)) (is-unique-value? db (first e-or-lookup-ref)))) (cas-inner-2 db e-or-lookup-ref a old-val new-val sha) (and (vector? e-or-lookup-ref) (= 4 (count e-or-lookup-ref)) (keyword? (first e-or-lookup-ref)) (= :as (nth e-or-lookup-ref 2)) (string? (last e-or-lookup-ref)) (or (is-identity? db (first e-or-lookup-ref)) (is-unique-value? db (first e-or-lookup-ref)))) (let [e (vec (take 2 e-or-lookup-ref))] (cond (some? (:db/id (d/pull db [:db/id] e))) (cas-inner-2 db e a old-val new-val sha) (nil? old-val) [[:db/add (last e-or-lookup-ref) a new-val] [:db/add \"datomic.tx\" :com.github.ivarref.double-trouble/sha-1 sha]] :else (d/cancel {:cognitect.anomalies/message \"Old-val must be nil for new entities\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}))) :else (d/cancel {:cognitect.anomalies/message \"Unhandled state\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}))))] (do (cas-inner db (to-clojure-types e-or-lookup-ref) (to-clojure-types attr) (to-clojure-types old-val) (to-clojure-types new-val) (to-clojure-types sha)))))}}" 
                :dt/sac "{:db/ident :dt/sac :db/fn #db/fn {:lang \"clojure\", :requires [[datomic.api :as d]], :imports [], :params [db e-or-lookup-ref attr new-val], :code (let [] (letfn [(is-ref? [db attr] (do (= :db.type/ref (d/q (quote [:find ?ident . :in $ ?e :where [?e :db/valueType ?typ] [?typ :db/ident ?ident]]) db attr)))) (get-val [db e a] (do (d/q (quote [:find ?v . :in $ ?e ?a :where [?e ?a ?v]]) db e a))) (most-recent-assert [db e a] (do (d/q (quote [:find (max ?tx) . :in $ ?e ?a :where [?e ?a _ ?tx true]]) (d/history db) e a)))] (do (cond (or (not (keyword? attr)) (nil? (:db/id (d/pull db [:db/id] attr)))) (d/cancel {:com.github.ivarref.double-trouble/attr attr, :com.github.ivarref.double-trouble/code :could-not-find-attr, :cognitect.anomalies/message \"Could not find attr\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}) (nil? new-val) (d/cancel {:com.github.ivarref.double-trouble/code :nil-not-supported, :cognitect.anomalies/message \"nil not supported\", :cognitect.anomalies/category :cognitect.anomalies/incorrect, :com.github.ivarref.double-trouble/lookup-ref e-or-lookup-ref}) (nil? (:db/id (d/pull db [:db/id] e-or-lookup-ref))) (d/cancel {:com.github.ivarref.double-trouble/code :could-not-find-entity, :cognitect.anomalies/message \"Could not find entity\", :cognitect.anomalies/category :cognitect.anomalies/incorrect, :com.github.ivarref.double-trouble/lookup-ref e-or-lookup-ref}) (and (is-ref? db attr) (keyword? new-val) (nil? (:db/id (d/pull db [:db/id] [:db/ident new-val])))) (d/cancel {:com.github.ivarref.double-trouble/code :could-not-find-ref-value, :com.github.ivarref.double-trouble/ref-value new-val, :cognitect.anomalies/message \"Could not find ref value\", :cognitect.anomalies/category :cognitect.anomalies/incorrect}) (nil? (get-val db e-or-lookup-ref attr)) [[:db/add e-or-lookup-ref attr new-val]] :else (let [resolved-value (if (and (is-ref? db attr) (keyword? new-val)) (:db/id (d/pull db [:db/id] [:db/ident new-val])) new-val)] (if (= (get-val db e-or-lookup-ref attr) resolved-value) (d/cancel {:com.github.ivarref.double-trouble/attr attr, :com.github.ivarref.double-trouble/code :no-change, :com.github.ivarref.double-trouble/tx (most-recent-assert db e-or-lookup-ref attr), :cognitect.anomalies/message \"No change\", :cognitect.anomalies/category :cognitect.anomalies/incorrect, :com.github.ivarref.double-trouble/lookup-ref e-or-lookup-ref}) [[:db/add e-or-lookup-ref attr new-val]]))))))}}"})
; End of generated code

(def schema
  (mapv (fn [s]
          (edn/read-string
            {:readers {'db/id  datomic.db/id-literal
                       'db/fn  datomic.function/construct}}
            s))
        (vals generated)))
